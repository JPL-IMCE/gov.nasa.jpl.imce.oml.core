/**
 * Copyright 2016 California Institute of Technology ("Caltech").
 * U.S. Government sponsorship acknowledged.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * License Terms
 */
package gov.nasa.jpl.imce.oml.generators;

import gov.nasa.jpl.imce.oml.model.extensions.OMLXcorePackages;
import java.util.Collections;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;

public class OMLUtilities extends OMLXcorePackages {
  public static class OMLTableCompare /* implements Comparator<EClass>  */{
    private final java.util.List knownTables = Collections.<java.lang.Object>unmodifiableList(CollectionLiterals.<java.lang.Object>newArrayList("Annotation", "AnnotationEntry", "AnnotationProperty", "AnnotationPropertyTable", "AnnotationSubjectPropertyValue", "AnnotationSubjectTable", "Extent", "TerminologyGraph", "Bundle", "ConceptDesignationTerminologyAxiom", "TerminologyExtensionAxiom", "TerminologyNestingAxiom", "Aspect", "Concept", "ReifiedRelationship", "UnreifiedRelationship", "Scalar", "Structure", "BinaryScalarRestriction", "IRIScalarRestriction", "NumericScalarRestriction", "PlainLiteralScalarRestriction", "ScalarOneOfRestriction", "StringScalarRestriction", "SynonymScalarRestriction", "TimeScalarRestriction", "EntityScalarDataProperty", "EntityStructuredDataProperty", "ScalarDataProperty", "StructuredDataProperty", "AspectSpecializationAxiom", "ConceptSpecializationAxiom", "ReifiedRelationshipSpecializationAxiom", "EntityExistentialRestrictionAxiom", "EntityUniversalRestrictionAxiom", "EntityScalarDataPropertyExistentialRestrictionAxiom", "EntityScalarDataPropertyParticularRestrictionAxiom", "EntityScalarDataPropertyUniversalRestrictionAxiom", "ScalarOneOfLiteralAxiom", "BundledTerminologyAxiom", "AnonymousConceptTaxonomyAxiom", "RootConceptTaxonomyAxiom", "SpecificDisjointConceptAxiom"));
    
    public Object compare(final /* EClass */Object c1, final /* EClass */Object c2) {
      throw new Error("Unresolved compilation problems:"
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\nThe field OMLUtilities.OMLTableCompare.knownTables refers to the missing type java.util.List"
        + "\nThe field OMLUtilities.OMLTableCompare.knownTables refers to the missing type java.util.List"
        + "\nname cannot be resolved"
        + "\nname cannot be resolved"
        + "\nindexOf cannot be resolved"
        + "\nindexOf cannot be resolved"
        + "\n> cannot be resolved"
        + "\n&& cannot be resolved"
        + "\n> cannot be resolved"
        + "\ncompareTo cannot be resolved"
        + "\n> cannot be resolved"
        + "\n&& cannot be resolved"
        + "\n== cannot be resolved"
        + "\n== cannot be resolved"
        + "\n&& cannot be resolved"
        + "\n> cannot be resolved"
        + "\ncompareTo cannot be resolved");
    }
  }
  
  public static class OMLFeatureCompare /* implements Comparator<ETypedElement>  */{
    private final java.util.List knownAttributes = Collections.<java.lang.Object>unmodifiableList(CollectionLiterals.<java.lang.Object>newArrayList("uuid", "tboxUUID", "extentUUID", "terminologyBundleUUID", "bundledTerminologyUUID", "extendedTerminologyUUID", "nestingTerminologyUUID", "nestingContextUUID", "bundleUUID", "moduleUUID", "descriptionBoxUUID", "refiningDescriptionBoxUUID", "singletonConceptClassifierUUID", "singletonReifiedRelationshipClassifierUUID", "dataStructureTypeUUID", "superAspectUUID", "subEntityUUID", "superConceptUUID", "subConceptUUID", "axiomUUID", "keyUUID", "subjectUUID", "propertyUUID", "closedWorldDefinitionsUUID", "refinedDescriptionBoxUUID", "refiningDescriptionBoxUUID", "dataStructureTypeUUID", "structuredDataPropertyValueUUID", "singletonInstanceUUID", "structuredDataPropertyUUID", "scalarDataPropertyUUID", "structuredPropertyTupleUUID", "singletonConceptClassifierUUID", "singletonReifiedRelationshipClassifierUUID", "reifiedRelationshipInstanceUUID", "unreifiedRelationshipUUID", "restrictedRelationUUID", "restrictedDomainUUID", "restrictedRangeUUID", "restrictedEntityUUID", "scalarPropertyUUID", "scalarRestrictionUUID", "domainUUID", "rangeUUID", "sourceUUID", "targetUUID", "superRelationshipUUID", "subRelationshipUUID", "rootUUID", "disjointTaxonomyParentUUID", "disjointLeafUUID", "kind", "isAbstract", "isAsymmetric", "isEssential", "isFunctional", "isInverseEssential", "isInverseFunctional", "isIrreflexive", "isReflexive", "isSymmetric", "isTransitive", "isIdentityCriteria", "minExclusive", "minInclusive", "maxExclusive", "maxInclusive", "length", "minLength", "maxLength", "nsPrefix", "name", "langRange", "pattern", "unreifiedPropertyName", "unreifiedInversePropertyName", "iri", "value", "scalarPropertyValue", "literalValue", "annotationsUUID", "boxStatementsUUID", "boxAxiomsUUID", "bundleStatementsUUID", "bundleAxiomsUUID"));
    
    public Object compare(final /* ETypedElement */Object o1, final /* ETypedElement */Object o2) {
      throw new Error("Unresolved compilation problems:"
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\n- cannot be resolved."
        + "\nThe field OMLUtilities.OMLFeatureCompare.knownAttributes refers to the missing type java.util.List"
        + "\nThe field OMLUtilities.OMLFeatureCompare.knownAttributes refers to the missing type java.util.List"
        + "\ncolumnName cannot be resolved"
        + "\ncolumnName cannot be resolved"
        + "\nindexOf cannot be resolved"
        + "\nindexOf cannot be resolved"
        + "\n> cannot be resolved"
        + "\n&& cannot be resolved"
        + "\n> cannot be resolved"
        + "\ncompareTo cannot be resolved"
        + "\n> cannot be resolved"
        + "\n&& cannot be resolved"
        + "\n== cannot be resolved"
        + "\n== cannot be resolved"
        + "\n&& cannot be resolved"
        + "\n> cannot be resolved"
        + "\ncompareTo cannot be resolved");
    }
  }
  
  public static /* String */Object queryResolverName(final /* EOperation */Object op, final /* String */Object typePrefix) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nEParameters cannot be resolved"
      + "\nname cannot be resolved"
      + "\nqueryResolverType cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object queryResolverType(final /* ETypedElement */Object feature, final /* String */Object typePrefix) {
    throw new Error("Unresolved compilation problems:"
      + "\nEDataType cannot be resolved to a type."
      + "\nEClass cannot be resolved to a type."
      + "\n- cannot be resolved."
      + "\nEType cannot be resolved"
      + "\nscalaResolverTypeName cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\nupperBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\ngetEAnnotation cannot be resolved"
      + "\ndetails cannot be resolved"
      + "\nget cannot be resolved"
      + "\n?: cannot be resolved"
      + "\nget cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nget cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object scalaResolverTypeName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nEType cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public static /* String */Object schemaColumnTypeName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nEClass cannot be resolved to a type."
      + "\nEType cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public static /* String */Object schemaColumnTypeDescription(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nschemaColumnTypeName cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object constructorTypeName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nscalaTableTypeName cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object javaArgName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\ncolumnName cannot be resolved"
      + "\n+ cannot be resolved"
      + "\ncolumnName cannot be resolved");
  }
  
  public static /* String */Object javaTypeName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nscalaTableTypeName cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object jsArgName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\ncolumnName cannot be resolved"
      + "\n+ cannot be resolved"
      + "\ncolumnName cannot be resolved");
  }
  
  public static /* String */Object jsTypeName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nscalaTableTypeName cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object scalaTableTypeName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nEClass cannot be resolved to a type."
      + "\nEType cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public static /* Iterable<EClass> */Object FunctionalAPIClasses(final /* EPackage */Object ePkg) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field EClass is undefined"
      + "\nInvalid number of arguments. The method isAPI(ENamedElement) is not applicable without arguments"
      + "\nThe method isAPI(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nEClassifiers cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nfilter cannot be resolved");
  }
  
  public static /* Boolean */Object isFunctionalAPIWithOrderingKeys(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nisFunctionalAPI cannot be resolved"
      + "\n! cannot be resolved"
      + "\norderingKeys cannot be resolved"
      + "\nempty cannot be resolved");
  }
  
  public static /* Iterable<ETypedElement> */Object orderingKeys(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isOrderingKey(ENamedElement) is not applicable without arguments"
      + "\nThe method isOrderingKey(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nfunctionalAPIOrOrderingKeyAttributes cannot be resolved"
      + "\nfilter cannot be resolved");
  }
  
  public static /* Iterable<ETypedElement> */Object functionalAPIOrOrderingKeyAttributes(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isInterface(ENamedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isFunctionalAttributeOrReferenceOrContainer(ETypedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isOrderingKey(ENamedElement) is not applicable without arguments"
      + "\nThe method isInterface(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isFunctionalAttributeOrReferenceOrContainer(ETypedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isOrderingKey(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nfunctionalAPIOrOrderingKeyFeatures cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\n! cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n|| cannot be resolved");
  }
  
  public static /* Iterable<ETypedElement> */Object functionalAPIOrOrderingKeyFeatures(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nSet cannot be resolved to a type."
      + "\nInvalid number of arguments. The method ETypedElements(EClass) is not applicable without arguments"
      + "\nETypedElement cannot be resolved to a type."
      + "\nThe method ETypedElements(EClass) from the type OMLUtilities refers to the missing type Iterable"
      + "\nselfAndAllSupertypes cannot be resolved"
      + "\nmap cannot be resolved"
      + "\nflatten cannot be resolved"
      + "\ntoSet cannot be resolved"
      + "\nsortWith cannot be resolved");
  }
  
  public static /* Boolean */Object hasOptionalAttributes(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nschemaAPIOrOrderingKeyAttributes cannot be resolved"
      + "\nexists cannot be resolved"
      + "\nlowerBound cannot be resolved"
      + "\n== cannot be resolved");
  }
  
  public static /* Iterable<ETypedElement> */Object schemaAPIOrOrderingKeyAttributes(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isInterface(ENamedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isSchemaAttributeOrReferenceOrContainer(ETypedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isOrderingKey(ENamedElement) is not applicable without arguments"
      + "\nThe method isInterface(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isSchemaAttributeOrReferenceOrContainer(ETypedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isOrderingKey(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nschemaAPIOrOrderingKeyFeatures cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\n! cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n|| cannot be resolved");
  }
  
  public static /* Iterable<ETypedElement> */Object schemaAPIOrOrderingKeyFeatures(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nSet cannot be resolved to a type."
      + "\nInvalid number of arguments. The method ETypedElements(EClass) is not applicable without arguments"
      + "\nETypedElement cannot be resolved to a type."
      + "\nThe method ETypedElements(EClass) from the type OMLUtilities refers to the missing type Iterable"
      + "\nselfAndAllSupertypes cannot be resolved"
      + "\nmap cannot be resolved"
      + "\nflatten cannot be resolved"
      + "\ntoSet cannot be resolved"
      + "\nsortWith cannot be resolved");
  }
  
  public static /* Iterable<ETypedElement> */Object ETypedElements(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nHashSet cannot be resolved."
      + "\nInvalid number of arguments. The method isFunctionalAPIOrOrderingKey(ENamedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isFunctionalAPIOrOrderingKey(ENamedElement) is not applicable without arguments"
      + "\nETypedElement cannot be resolved to a type."
      + "\nThe method isFunctionalAPIOrOrderingKey(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isFunctionalAPIOrOrderingKey(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\naddAll cannot be resolved"
      + "\nEStructuralFeatures cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\naddAll cannot be resolved"
      + "\nEOperations cannot be resolved"
      + "\nfilter cannot be resolved");
  }
  
  public static /* Iterable<EClass> */Object selfAndAllSupertypes(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nHashSet cannot be resolved."
      + "\nEAllSuperTypes cannot be resolved"
      + "\nadd cannot be resolved");
  }
  
  public static /* Iterable<EClass> */Object ESuperClasses(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field name is undefined"
      + "\nESuperTypes cannot be resolved"
      + "\nsortBy cannot be resolved");
  }
  
  public static /* Iterable<EClass> */Object ESpecificClasses(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field EClass is undefined"
      + "\nThe method or field ESuperTypes is undefined"
      + "\nThe method or field name is undefined"
      + "\nEPackage cannot be resolved"
      + "\nEClassifiers cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\ncontains cannot be resolved"
      + "\nsortBy cannot be resolved");
  }
  
  public static /* Iterable<EStructuralFeature> */Object APIStructuralFeatures(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isAPI(ENamedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isFunctionalAttributeOrReferenceOrContainer(ETypedElement) is not applicable without arguments"
      + "\nInvalid number of arguments. The method isOrderingKey(ENamedElement) is not applicable without arguments"
      + "\nThe method isAPI(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isFunctionalAttributeOrReferenceOrContainer(ETypedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nThe method isOrderingKey(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nEStructuralFeatures cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\n|| cannot be resolved");
  }
  
  public static /* Boolean */Object isRootHierarchyClass(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nisAbstract cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nESuperTypes cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n&& cannot be resolved"
      + "\norderingKeys cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public static /* Boolean */Object isSpecializationOfRootClass(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isRootHierarchyClass(EClass) is not applicable without arguments"
      + "\nThe method isRootHierarchyClass(EClass) from the type OMLUtilities refers to the missing type Boolean"
      + "\nESuperTypes cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nselfAndAllSupertypes cannot be resolved"
      + "\nexists cannot be resolved");
  }
  
  public static /* Iterable<EOperation> */Object APIOperations(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isAPI(ENamedElement) is not applicable without arguments"
      + "\nThe method isAPI(ENamedElement) from the type OMLUtilities refers to the missing type Boolean"
      + "\nEOperations cannot be resolved"
      + "\nfilter cannot be resolved");
  }
  
  public static /* Iterable<EStructuralFeature> */Object getSortedDerivedAttributeSignature(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field derived is undefined"
      + "\ngetSortedAttributeSignature cannot be resolved"
      + "\nfilter cannot be resolved");
  }
  
  public static /* Iterable<EStructuralFeature> */Object getSortedAttributeSignatureExceptDerived(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field derived is undefined"
      + "\ngetSortedAttributeSignature cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public static /* Iterable<EStructuralFeature> */Object getSortedAttributeSignature(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method APIStructuralFeatures(EClass) is not applicable without arguments"
      + "\nThe method APIStructuralFeatures(EClass) from the type OMLUtilities refers to the missing type Iterable"
      + "\nselfAndAllSupertypes cannot be resolved"
      + "\nmap cannot be resolved"
      + "\nflatten cannot be resolved"
      + "\nsortWith cannot be resolved");
  }
  
  public static /* Iterable<EStructuralFeature> */Object lookupCopyConstructorArguments(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\nInvalid number of arguments. The method isCopyConstructorArgument(EStructuralFeature) is not applicable without arguments"
      + "\nThe method isCopyConstructorArgument(EStructuralFeature) from the type OMLUtilities refers to the missing type Boolean"
      + "\ngetSortedAttributeSignature cannot be resolved"
      + "\nfilter cannot be resolved");
  }
  
  public static /* Boolean */Object isCopyConstructorArgument(final /* EStructuralFeature */Object attribute) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Iterable<EOperation> */Object ScalaOperations(final /* EClass */Object eClass) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\nAPIOperations cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nisScala cannot be resolved"
      + "\n|| cannot be resolved"
      + "\nxExpressions cannot be resolved");
  }
  
  public static /* Iterable<XExpression> */Object xExpressions(final /* EOperation */Object op) {
    throw new Error("Unresolved compilation problems:"
      + "\nXcoreMapper cannot be resolved."
      + "\ngetXOperation cannot be resolved"
      + "\nbody cannot be resolved"
      + "\nexpressions cannot be resolved");
  }
  
  public static /* String */Object queryBody(final /* EOperation */Object op) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\n!== cannot be resolved."
      + "\nscalaAnnotation cannot be resolved"
      + "\nxExpressions cannot be resolved"
      + "\ntoScala cannot be resolved");
  }
  
  /**
   * Transform an XText base XExpression to an equivalent Scala expression in concrete syntax (String).
   */
  public static /* String */Object toScala(final /* XExpression */Object exp) {
    throw new Error("Unresolved compilation problems:"
      + "\nXFeatureCall cannot be resolved to a type."
      + "\nXMemberFeatureCall cannot be resolved to a type."
      + "\nThe method or field NodeModelUtils is undefined"
      + "\nThe method or field NodeModelUtils is undefined"
      + "\nIllegalArgumentException cannot be resolved."
      + "\nIllegalArgumentException cannot be resolved."
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nfindActualNodeFor cannot be resolved"
      + "\ngetTokenText cannot be resolved"
      + "\nactualReceiver cannot be resolved"
      + "\ntoScala cannot be resolved"
      + "\nactualArguments cannot be resolved"
      + "\nempty cannot be resolved"
      + "\n! cannot be resolved"
      + "\nfeature cannot be resolved"
      + "\neIsProxy cannot be resolved"
      + "\n+ cannot be resolved"
      + "\ntoString cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\neResource cannot be resolved"
      + "\nURI cannot be resolved"
      + "\nsimpleName cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\ntoString cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object queryBody(final /* EStructuralFeature */Object f) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\nscalaAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isFunctionalAPIOrOrderingKey(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\nisFunctionalAPI cannot be resolved"
      + "\n|| cannot be resolved"
      + "\nisOrderingKey cannot be resolved");
  }
  
  public static /* Boolean */Object isFunctionalAPI(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\nEClass cannot be resolved to a type."
      + "\nisSchema cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nisAPI cannot be resolved"
      + "\nisAbstract cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public static /* Boolean */Object isFunctionalAttributeOrReferenceOrContainer(final /* ETypedElement */Object f) {
    throw new Error("Unresolved compilation problems:"
      + "\nEReference cannot be resolved to a type."
      + "\ncontainer cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public static /* Boolean */Object isSchemaAttributeOrReferenceOrContainer(final /* ETypedElement */Object f) {
    throw new Error("Unresolved compilation problems:"
      + "\nEReference cannot be resolved to a type."
      + "\nisSchema cannot be resolved"
      + "\n&& cannot be resolved"
      + "\ncontainment cannot be resolved"
      + "\n! cannot be resolved"
      + "\nisSchema cannot be resolved");
  }
  
  public static /* EClass */Object EClassContainer(final /* ETypedElement */Object f) {
    throw new Error("Unresolved compilation problems:"
      + "\nEClass cannot be resolved to a type."
      + "\neContainer cannot be resolved");
  }
  
  public static /* Boolean */Object isClassFeature(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nEClass cannot be resolved to a type."
      + "\nEType cannot be resolved");
  }
  
  public static /* Boolean */Object isOrderingKey(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isOverride(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isOO(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isInterface(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isAPI(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n=== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isGlossary(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isScala(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* String */Object scalaAnnotation(final /* ETypedElement */Object f) {
    throw new Error("Unresolved compilation problems:"
      + "\ngetEAnnotation cannot be resolved"
      + "\ndetails cannot be resolved"
      + "\nget cannot be resolved");
  }
  
  public static /* Boolean */Object isSchema(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n=== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nisResolverAPI cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  public static /* Boolean */Object isResolverAPI(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* Boolean */Object isValueTable(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\n!== cannot be resolved."
      + "\ngetEAnnotation cannot be resolved");
  }
  
  public static /* String */Object pluralizeIfMany(final /* String */Object s, final int cardinality) {
    throw new Error("Unresolved compilation problems:"
      + "\n> cannot be resolved."
      + "\nThe method pluralize(String) from the type OMLUtilities refers to the missing type String");
  }
  
  public static /* String */Object pluralize(final /* String */Object s) {
    throw new Error("Unresolved compilation problems:"
      + "\nendsWith cannot be resolved"
      + "\nsubstring cannot be resolved"
      + "\nlength cannot be resolved"
      + "\n- cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object columnName(final /* ETypedElement */Object feature) {
    throw new Error("Unresolved compilation problems:"
      + "\nEReference cannot be resolved to a type."
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  public static /* String */Object markDown(final /* ENamedElement */Object e) {
    throw new Error("Unresolved compilation problems:"
      + "\ngetEAnnotation cannot be resolved"
      + "\ndetails cannot be resolved"
      + "\nget cannot be resolved"
      + "\n?: cannot be resolved");
  }
  
  public static /* String */Object doc(final /* ENamedElement */Object e, final /* String */Object indent) {
    throw new Error("Unresolved compilation problems:"
      + "\ngetEAnnotation cannot be resolved"
      + "\ndetails cannot be resolved"
      + "\nget cannot be resolved"
      + "\n?: cannot be resolved"
      + "\nempty cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nreplaceAll cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved"
      + "\n+ cannot be resolved");
  }
  
  public static /* String */Object copyright() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Copyright 2016 California Institute of Technology (\"Caltech\").");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* U.S. Government sponsorship acknowledged.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Licensed under the Apache License, Version 2.0 (the \"License\");");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* you may not use this file except in compliance with the License.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* You may obtain a copy of the License at");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*     http://www.apache.org/licenses/LICENSE-2.0");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* Unless required by applicable law or agreed to in writing, software");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* distributed under the License is distributed on an \"AS IS\" BASIS,");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* See the License for the specific language governing permissions and");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* limitations under the License.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* License Terms");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
}
