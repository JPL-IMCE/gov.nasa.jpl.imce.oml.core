@Ecore(nsPrefix="oml", nsURI="http://imce.jpl.nasa.gov/oml")
@GenModel(copyrightText="
Copyright 2016 California Institute of Technology (\"Caltech\").
U.S. Government sponsorship acknowledged.

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
", bundleManifest="false",
   complianceLevel="8.0",
   modelDirectory="oml.model/build/xcore/main")
   
package gov.nasa.jpl.imce.oml

/* 
 * If present, the value of the 'kind' key specifies a Scala immutable collection.
 * Recognized values are 'Map' (the key type is specified in the 'key' value) and 'Set'
 */
annotation "http://imce.jpl.nasa.gov/oml/Collection" as Collection

/* 
 * If present, indicates that this feature overrides another feature in a parent.
 * Normally, this information should be accessible from the EMF API; however,
 * it is not obvious how to get it.
 */
annotation "http://imce.jpl.nasa.gov/oml/Override" as Override

/*
 * If present, disables including the feature in the resolver API & resolver Implementation
 * This is used for:
 * - classes that are intended for the EMF API but not the functional resolver API
 * - operations that will generate an EMF API operation but have no sensible equivalent in the functional resolver API
 * - structural features with a corresponding read-only immutable query operation
 *   (the structural feature is not part of the functional API; the immutable query operation is)
 * - inverse container features
 */
annotation "http://imce.jpl.nasa.gov/oml/NotFunctionalAPI" as NotFunctionalAPI

/*
 * If present, specifies that the annotated method is intended as an interface operation;
 * not for generating an implementation.
 */
annotation "http://imce.jpl.nasa.gov/oml/FunctionalInterface" as FunctionalInterface

/*
 * If present, disables including the feature in the normalized schema tables API
 */
annotation "http://imce.jpl.nasa.gov/oml/NotSchema" as NotSchema

/*
 * If present, indicates that a Class represents a value in some other table
 */
annotation "http://imce.jpl.nasa.gov/oml/ValueTable" as ValueTable

/*
 * Use @Scala(code="...") when the XCore operation body
 * is an Xbase XMemberFeatureCall because the XCore API
 * assumes that the generated code is for Java so it internally
 * converts feature calls into Java query operation calls.
 */
annotation "http://imce.jpl.nasa.gov/oml/Scala" as Scala

/*
 * Use on structural features to specify whether it participates in ordering criteria for instances of the class.
 */
annotation "http://imce.jpl.nasa.gov/oml/IsOrderingKey" as IsOrderingKey

/*
 * Use on a structural feature to specify that the OMLResolvedFactory needs to include a "copy" constructor
 * to clone an instance of the feature's class replacing the value of the annotated feature. 
 */
annotation "http://imce.jpl.nasa.gov/oml/CopyConstructor" as CopyConstructor

/*
 * If present, indicates that a glossary entry must be generated for the documentation.
 */
annotation "http://imce.jpl.nasa.gov/oml/Glossary" as Glossary

type OTI_TOOL_SPECIFIC_ID wraps String

type OTI_TOOL_SPECIFIC_UUID wraps String

type OTI_TOOL_SPECIFIC_URL wraps String

/*
 * A 3 or 4 tuple establishing the provenance between:
 * - an OML TerminologyThing (identified by its primary key: omlUUID)
 * - an OTI UMLElement (identified by its keys: otiID, otiURL, and, if available, otiUUID)
 */
@NotFunctionalAPI
class OML2OTIProvenance {
	
	/*
	 * The OML UUID of a TerminologyThing mapped to OTI
	 */
	UUID[1] omlUUID
	
	/*
	 * The OTI tool-specific ID of the OTI element mapped from an OML TerminologyThing
	 */
	OTI_TOOL_SPECIFIC_ID[1] otiID
	
	/*
	 * The OTI tool-specific URL of the OTI element mapped from an OML TerminologyThing
	 */
	OTI_TOOL_SPECIFIC_URL[1] otiURL
	
	/*
	 * The OTI tool-specific UUID of the OTI element mapped from an OML TerminologyThing
	 */
	OTI_TOOL_SPECIFIC_UUID[?] otiUUID
	
	/*
	 * Explanation of the OML to OTI provenance mapping
	 */
	String[1] explanation
}

/*
 * An IRI based on RFC 3987
 */
type IRI wraps String
/*
 * A local name of an IRI
 */
type LocalName wraps String
/*
 * A lexical value for a real, a decimal or an integer number
 */
type LexicalValue wraps String
/*
 * A lexical value for a real, a decimal or an integer number
 */
type LexicalNumber wraps String
/*
 * A lexical value for a time instant with and without time zone offsets
 */
type LexicalTime wraps String
/*
 * A regular expression for a string based on rule of xsd:pattern
 */
type Pattern wraps String
/*
 * An RFC-4122 UUID (either Version 4 (random) or Version 5 (SHA-1 hash & namespace) 
 */
type UUID wraps String
/*
 * A language range based on RFC 5646
 */
type LangRange wraps String

type AbbrevIRI wraps String

type NamespacePrefix wraps String

/*
 * An OML Resource is an abstraction for 
 * everything in a vocabulary that is identifiable
 * locally by name within the vocabulary and 
 * globally by an IRI across multiple vocabularies.
 * For a particular OML Resource, the constraints 
 * between its name and its IRI depend on what kind of OML Resource it is.
 */
@Glossary
abstract class Resource {
	
	@NotSchema
	op IRI[1] iri()
	
	@NotSchema
	op LocalName[1] name()
}

/*
 * An OML TerminologyThing is a logical abstraction for everything
 * in a vocabulary that is globally identified by a UUID.
 */
@Glossary
abstract class TerminologyThing {
	
	@Scala(code="calculateUUID()")
	@IsOrderingKey
	derived UUID[1] uuid get { calculateUUID() }
	
	@NotSchema
	op UUID[1] calculateUUID()
}

/*
 * An OML AnnotationProperty maps to an [OWL2 AnnotationProperty] 
 * and is similarly a non-logical property for associating some information
 * to any OML TerminologyThing in an OML Module.
 */
@Glossary
class AnnotationProperty {
	
	@Scala(code="java.util.UUID.fromString(iri)")
	@IsOrderingKey
	op UUID[1] uuid() { java.util.UUID.fromString(iri).toString }
	
	IRI[1] iri
	
	id AbbrevIRI[1] abbrevIRI
}

/* 
 * For the OML tabular interchange representation,
 * an OML AnnotationPropertyTable pairs an OML AnnotationProperty key
 * with a set of OML AnnotationEntry values.
 */
@Glossary
@NotSchema
class AnnotationPropertyTable wraps java.util.Map$Entry {
	
	@IsOrderingKey
	refers AnnotationProperty[1] key
	
	@Collection(kind="SortedSet")
	contains AnnotationEntry[] value
}

/*
 * For the OML tabular interchange representation,
 * an OML AnnotationEntry (for a given OML AnnotationProperty) is a triple:
 * - an OML Module in which the OML AnnotationEntry appears 
 * - an annotated OML TerminologyThing subject
 * - a String value as the representation of some information
 *   about the subject in that module.
 */
@Glossary
@ValueTable
class AnnotationEntry {
	
	@IsOrderingKey
	refers Module[1] module
	
	@IsOrderingKey 
	refers TerminologyThing[1] subject
	
	@IsOrderingKey
	String[1] value
}

/* 
 * An OML AnnotationSubjectTable is an in-memory construct
 * pairing an OML TerminologyThing subject key with a set
 * of OML AnnotationSubjectPropertyValue tuples.
 */
@Glossary
@NotFunctionalAPI
@NotSchema
class AnnotationSubjectTable wraps java.util.Map$Entry {
	refers TerminologyThing[1] key
	
	contains AnnotationSubjectPropertyValue[] value
}

/*
 * An OML AnnotationSubjectPropertyValue is an in-memory construct
 * pairing an OML AnnotationProperty with a String value.
 */
@Glossary
@NotFunctionalAPI
@NotSchema
class AnnotationSubjectPropertyValue {
	refers AnnotationProperty[1] property
	String[1] value
}

/*
 * An OML Annotation maps to an [OWL2 Annotation] and is similarly
 * a non-logical statement in an OML Module
 * associating some information as the value of an
 * OML AnnotationProperty for describing a subject (an OML TerminologyThing).
 */
@Glossary
@NotSchema
class Annotation {
	
	@IsOrderingKey
	container Module[1] module opposite annotations
	
	@IsOrderingKey
	refers AnnotationProperty[1] property
	
	@IsOrderingKey
	refers TerminologyThing[1] subject
	
	@IsOrderingKey
	String[1] value
}

/*
 * An OML TerminologyExtent defines an in-memory tuple
 * about each OML Module involved in modeling and reasoning about domain-specific
 * vocabularies and systems descriptions using such vocabularies:
 * - An OML TerminologyGraph for defining a vocabulary about a domain or a description of a system in a domain;
 * - An OML Bundle for aggregating OML TerminologyBox(es) for as modular [OWL2-DL Ontologies] for monotonic refinement and reasoning;
 * - An OML DescriptionBox for describing actual systems according to one or more domain-specific OML TerminologyBox vocabularies.
 */
@Glossary
@NotSchema
class TerminologyExtent {
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains AnnotationProperty[] annotationProperties
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains TerminologyGraph[] terminologyGraphs opposite graphExtent
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains Bundle[] bundles opposite bundleExtent
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains DescriptionBox[] descriptions opposite descriptionExtent
}

/*
 * An OML Module maps to an [OWL2-DL Ontology];
 * it is a kind of OML Resource that is a logical container of OML TerminologyThing(s)
 * and a non-logical container of OML Annotation(s).
 */
@Glossary
abstract class Module extends TerminologyThing, Resource {

	@NotSchema
	op TerminologyExtent[1] extent()
	
	@Scala(code="com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri()).toString
	}
	
	@Override
	id IRI[1] iri
	
	@NotFunctionalAPI
	op IRI[1] iri() { getIri() }
	
	@Scala(code="iri.substring(1+iri.lastIndexOf('/'))")
	@NotSchema
 	op NamespacePrefix[1] nsPrefix() { getIri().substring(1+getIri().lastIndexOf('/')) }
	
	@NotSchema
	op LocalName[1] name() { nsPrefix }
	
	@NotSchema
	@Collection(kind="SortedSet")
	contains Annotation[] annotations opposite module
	
	@NotFunctionalAPI
	op AnnotationSubjectTable[] annotationsBySubject()
	
	@NotSchema
	@Collection(kind="SortedSet")
	op AnnotationPropertyTable[] annotationsByProperty()
	
	@NotSchema
	op Module[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
    @NotSchema
	@Collection(kind="SortedSet")
	op Entity[] entities()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op Aspect[] aspects()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op Concept[] concepts()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op ReifiedRelationship[] reifiedRelationships()
		
    @NotSchema
	@Collection(kind="SortedSet")
	op UnreifiedRelationship[] unreifiedRelationships()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op DataRelationship[] dataRelationships()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op EntityScalarDataProperty[] entityScalarDataProperties()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op DataRange[] dataranges()

    @NotSchema
	@Collection(kind="SortedSet")
	op Scalar[] scalars()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op Structure[] structures()
	
    @NotSchema
	@Collection(kind="SortedSet")
	op TermAxiom[] termAxioms()
	
	@NotSchema
	@Collection(kind="SortedSet")
	op TerminologyThing[] everything()
}

/*
 * An OML TerminologyBox is an OML Module for defining a domain-specific vocabulary
 * as a logical set of OML TerminologyBoxStatement(s), 
 * possibly by reuse of other vocabularies via OML TerminologyBoxAxiom(s).
 * The semantics of an OML TerminologyBox domain-specific vocabulary is defined
 * by the mapping to [OWL2-DL] of the other vocabularies it reuses, if any, and
 * that of its OML TerminologyBoxAxiom(s) and OML TerminologyBoxStatement(s) 
 * according to its OML TerminologyGraphKind. 
 */
@Glossary
abstract class TerminologyBox extends Module {
	
	TerminologyGraphKind[1] kind
	
	/*
	 * The TerminologyBoxAxioms asserted in this TerminologyBox
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBoxAxiom[] terminologyBoxAxioms opposite tbox
	
	/*
	 * The TerminologyBoxStatements asserted in this TerminologyBox
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBoxStatement[] boxStatements opposite tbox
	 
	@NotSchema
	op TerminologyBox[1] withBoxStatements
	(@Collection(kind="SortedSet") TerminologyBoxStatement[] s)
	
	/*
	 * The subset of statements that are entities.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case e: Entity => e }")
	@Collection(kind="SortedSet")
	@Override
	op Entity[] entities()
	
	/*
	 * The subset of statements that are aspects.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case a: Aspect => a }")
	@Collection(kind="SortedSet")
	@Override
	op Aspect[] aspects()
	
	/*
	 * The subset of statements that are concepts.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case c: Concept => c }")
	@Collection(kind="SortedSet")
	@Override
	op Concept[] concepts()
	
	/*
	 * The subset of statements that are reified relationships.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case rr: ReifiedRelationship => rr }")
	@Collection(kind="SortedSet")
	@Override
	op ReifiedRelationship[] reifiedRelationships()
		
	/*
	 * The subset of statements that are unreified relationships.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case ur: UnreifiedRelationship => ur }")
	@Collection(kind="SortedSet")
	@Override
	op UnreifiedRelationship[] unreifiedRelationships()
	
	/*
	 * The subset of statements that are data relationships.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case dr: DataRelationship => dr }")
	@Collection(kind="SortedSet")
	@Override
	op DataRelationship[] dataRelationships()
	
	/*
	 * A map for the subset of statements that are 
	 * entity scalar data property terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case dp: EntityScalarDataProperty => dp }")
	@Collection(kind="SortedSet")
	@Override
	op EntityScalarDataProperty[] entityScalarDataProperties()
	
	/*
	 * A map for the subset of statements that are 
	 * data range terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case dr: DataRange => dr }")
	@Collection(kind="SortedSet")
	@Override
	op DataRange[] dataranges()
	
	/*
	 * A map for the subset of statements that are 
	 * scalar datatype terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case s: Scalar => s }")
	@Collection(kind="SortedSet")
	@Override
	op Scalar[] scalars()
	
	/*
	 * A map for the subset of statements that are 
	 * structured datatype terms indexed by their uuid.
     */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case s: Structure => s }")
	@Collection(kind="SortedSet")
	@Override
	op Structure[] structures()
	
	/*
	 * The subset of axioms about terms.
	 */
    @NotSchema
	@Scala(code="boxStatements.selectByKindOf { case tx: TermAxiom => tx }")
	@Collection(kind="SortedSet")
	@Override
	op TermAxiom[] termAxioms()
	
	@NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.TerminologyThing] ++ boxStatements + this")
	@Collection(kind="SortedSet")
	@Override
	op TerminologyThing[] everything()
}

/*
 * An OML Bundle is an OML TerminologyBox that is 
 * an acyclic logical aggregate of other OML TerminologyBox(es)
 * and that logically assert OML TerminologyBundleStatement(s).
 */
@Glossary
class Bundle extends TerminologyBox {
	
	@NotSchema
	op TerminologyExtent[1] extent() { bundleExtent }
		
	@NotSchema
	container TerminologyExtent[1] bundleExtent opposite bundles
	
	@NotSchema
	@Scala(code="copy(annotations = this.annotations ++ resolver.convertToAnnotations(a))")
	@Override
	op Bundle[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
	@NotSchema
	@Scala(code="resolver.groupAnnotationsByProperty(annotations)")
	@Collection(kind="SortedSet")
	@Override
	op AnnotationPropertyTable[] annotationsByProperty()	
	
	/*
	 * The TerminologyBundleStatements asserted in this Bundle
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBundleStatement[] bundleStatements opposite bundle
	
	/*
	 * The BundledTerminologyAxioms asserted in this Bundle
	 */
	@NotSchema
	@Collection(kind="SortedSet")
	contains TerminologyBundleAxiom[] terminologyBundleAxioms opposite terminologyBundle
			
	@NotSchema
	@Scala(code="copy(bundleStatements = this.bundleStatements ++ s)")
	op Bundle[1] withBundleStatements
	(@Collection(kind="SortedSet") TerminologyBundleStatement[] s)
	
	@NotSchema
	@Scala(code="copy(boxStatements = this.boxStatements ++ s)")
	@Override
	op Bundle[1] withBoxStatements
	(@Collection(kind="SortedSet") TerminologyBoxStatement[] s)

	@NotSchema
	@Scala(code="super.everything() ++ bundleStatements + this")
	@Collection(kind="SortedSet")
	@Override
	op TerminologyThing[] everything()
}

/*
 * OML supports two different interpretations for OML TerminologyBox vocabularies:
 * - An open-world interpretation where the vocabulary formalizes a particular domain 
 *   that will be used for modeling particular systems in that domain.
 * - A closed-world interpretation where the vocabulary formalizes the description of
 *   a particular system modeled using the open-world vocabulary for a particular domain.
 * The difference between these interpretations primarily affects the mapping to an [OWL2-DL Class]
 * of a concrete OML ConceptualEntity as follows:
 * - For OpenWorldDefinitions, the mapped [OWL2-DL Class] has open-world semantics; that is,
 *   it classifies a set of individuals that share the characteristics and capabilities 
 *   encoded in the [OWL2-DL Class].
 * - For ClosedWorldDefinitions, the mapped [OWL2-DL Class] has a closed-world semantics in
 *   the sense that it is intended to classify a singleton individual uniquely identified
 *   via the values of its identifying OML DataRelationshipFromEntity properties.
 */
@Glossary
enum TerminologyGraphKind {
	/*
	 * Each OML Entity in an OpenWorldDefinitions OML TerminologyBox has the semantics of
	 * an [OWL2-DL Class]; that is, it classifies a set of individuals 
	 * that share the characteristics and capabilities encoded in the [OWL2-DL Class].
	 * A well-formed OML SpecializationAxiom establishing a taxonomic relationship between 
	 * two OML Term(s) can be asserted arbitrarily in any OpenWorldDefinitions OML TerminologyBox 
	 * that directly or indirectly includes the related OML Term(s). 
	 * For example, suppose that OML Concept(s) `A` and `B`
	 * are defined in OpenWorldDefinitions OML TerminologyBox `P` and `Q` respectively. 
	 * Suppose further that OpenWorldDefinitions OML TerminologyBox(es), `U` and `V`, each
	 * extend both `P` and `Q` where `U` asserts that `A` extends `B` while `V` asserts that `B` extends `A.
	 * This is well-formed; furthermore, an OpenWorldDefinitions OML TerminologyBox extending both `U` and `V` 
	 * would force `A` and `B` to become equivalent OML Concept(s) per the open-world semantics of [OWL2-DL].
	 */
	OpenWorldDefinitions
	/*
	 * Each OML ConceptualEntity in a ClosedWorldDesignation terminology describes a unique thing 
	 * in the real world uniquely identifiable by the collection of its identifying OML DataRelationshipFromEntity properties
	 * (e.g., serial numbers, unique identifiers, ...).
	 * A well-formed ClosedWorldDesignations OML TerminologyBox is restricted to defining singleton OML ConceptualEntity(-ies), each as
	 * a specialization of at least one concrete OML ConceptualEntity defined  in an extended OpenWorldDefinitions OML TerminologyBox.
	 * Each OML ConceptualEntity in a ClosedWorldDesignations OML TerminologyBox maps to
	 * an [OWL2-DL Class] with an axiom asserting its equivalence to an exact cardinality restriction of 1 for
	 * each of its identifying OML DataRelationshipFromEntity properties.
	 */
	ClosedWorldDesignations
}

/*
 * An OML TerminologyGraph is an OML TerminologyBox with no statements our axioms involving OML Bundle(s).
 */
@Glossary
class TerminologyGraph extends TerminologyBox {
	
	@NotSchema
	op TerminologyExtent[1] extent() { graphExtent }
		
	@NotSchema
	container TerminologyExtent[1] graphExtent opposite terminologyGraphs
	
	@NotSchema
	@Scala(code="copy(annotations = this.annotations ++ resolver.convertToAnnotations(a))")
	@Override
	op TerminologyGraph[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
	@NotSchema
	@Scala(code="resolver.groupAnnotationsByProperty(annotations)")
	@Collection(kind="SortedSet")
	@Override
	op AnnotationPropertyTable[] annotationsByProperty()	
	
	@NotSchema
	@Scala(code="copy(boxStatements = this.boxStatements ++ s)")
	@Override
	op TerminologyGraph[1] withBoxStatements
	(@Collection(kind="SortedSet") TerminologyBoxStatement[] s)
}

/*
 * An OML TerminologyBoxStatement is a logical axiom about an OML TerminologyThing
 * in an OML TerminologyBox.
 */
@Glossary
abstract class TerminologyBoxStatement extends TerminologyThing {
	
	container TerminologyBox[1] tbox opposite boxStatements
}

/*
 * An OML TerminologyBundleStatement is a logical axiom about an OML TerminologyThing
 * in an OML Bundle.
 */
@Glossary
abstract class TerminologyBundleStatement extends TerminologyThing {
	
	container Bundle[1] bundle opposite bundleStatements
}

/*
 * An OML Term map to the declaration of an [OWL2-DL Entity] of some kind.
 */
@Glossary
abstract class Term extends TerminologyBoxStatement, Resource {
	
	/*
	 * The UUID of a Term is a Version5 namespace UUID based on the term's IRI.
	 */
	@Scala(code="com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri())")
	@NotSchema 
	@Override
	op UUID[1] calculateUUID() { 
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri()).toString
	}
	
	@Scala(code="tbox.iri + \"#\" + name")
	@NotSchema
	@Override
	op IRI[1] iri() { getTbox.iri() + "#" + name() }
	
	@Override
	id LocalName[1] name
	
	@NotFunctionalAPI
	@NotSchema
	op LocalName[1] name() { getName() }
}

/*
 * An OML UnaryTermKind is an abstraction for the category of OML Term(s)
 * that are relationships with arity 1
 */
@Glossary
abstract class UnaryTermKind {}

/*
 * An OML DirectedBinaryRelationshipKind is an abstraction 
 * for the category of OML Term(s)
 * that are relationships with arity 2
 */
@Glossary
abstract class DirectedBinaryRelationshipKind {
	
	@NotSchema
	op Term[1] relationDomain()
	
	@NotSchema
	op Term[1] relationRange()
}

/*
 * An OML Entity is an abstraction for an OML Term
 * that is either an OML UnaryTermKind or
 * an OML DirectedBinaryRelationshipKind whose subject
 * and range are both a kind of OML Entity.
 */
@Glossary
abstract class Entity extends Term {}

/*
 * An OML ConceptualEntity is an OML Entity
 * that can be either abstract or concrete.
 * An abstract OML ConceptualEntity cannot have any instance
 * in a final OML DescriptionBox.
 * A concrete OML ConceptualEntity can be partially instantiated
 * as an OML ConceptualEntitySingletonInstance in any OML DescriptionBox.
 * If is partially instantiated if some essential OML EntityRelationship
 * or OML DataRelationshipFromEntity with `isIdentityCriteria=true` lacks
 * an OML TerminologyInstanceAssertion specifying its reference or value respectively.
 */
@Glossary
abstract class ConceptualEntity {
	boolean[1] isAbstract
}

/*
 * An OML Aspect is a kind of OML Entity of OML UnaryTermKind.
 * It is intended to be used as a specialization parent
 * for one or more OML ConceptualEntity.
 */
@Glossary
class Aspect extends Entity, UnaryTermKind {}

/*
 * An OML Concept is an OML ConceptualEntity of OML UnaryTermKind.
 */
@Glossary
class Concept extends Entity, ConceptualEntity, UnaryTermKind {}

/*
 * An OML EntityRelationship is a kind of OML Term that
 * is an OML DirectedBinaryRelationshipKind between a
 * domain OML Entity and a range OML Entity.
 */
@Glossary
abstract class EntityRelationship extends Term, DirectedBinaryRelationshipKind {

 	refers Entity[1] source

	@NotSchema
	@Override
	op Term[1] relationDomain() { source }

 	refers Entity[1] target

	@NotSchema
	@Override
	op Term[1] relationRange() { target }
	
 	/*
 	 * 0 <= target.size <= 1
	 */
	boolean[1] isFunctional
 	/*
 	 * 0 <= source.size <= 1
	 */ 	 
 	boolean[1] isInverseFunctional
 	/*
 	 * 1 <= target.size
	 */
 	boolean[1] isEssential
 	/*
 	 * 1 <= source.size 	
	 */
 	boolean[1] isInverseEssential
 	/*
 	 * Whether this relationship is symmetric
	 */
 	boolean[1] isSymmetric
 	/*
 	 * Whether this relationship is asymmetric
	 */
 	boolean[1] isAsymmetric
 	/*
 	 * Whether this relationship is reflexive
	 */
 	boolean[1] isReflexive
 	/*
 	 * Whether this relationship is irreflexive
	 */ 	 
 	boolean[1] isIrreflexive
 	/*
 	 * Whether this relationship is transitive
	 */
 	boolean[1] isTransitive
}

/*
 * An OML ReifiedRelationship is an OML ConceptualEntity and a kind of OML EntityRelationship
 * where an instance has an intrinsic identity. This means that
 * an OML ReifiedRelationship can be involved as the domain or the
 * range of another OML EntityRelationship as well as the
 * domain of an OML DataRelationshipFromEntity.
 */
@Glossary
class ReifiedRelationship extends EntityRelationship, Entity, ConceptualEntity {

	LocalName[1] unreifiedPropertyName
	LocalName[?] unreifiedInversePropertyName
}

/*
 * An OML UnreifiedRelationship is a kind of OML EntityRelationship
 * where an instance has no intrinsic identity but rather structural
 * equivalence semantics as a tuple of references. This means
 * that an OML UnreifiedRelationship cannot be involved as the domain
 * or range of any kind of OML DirectedBinaryRelationshipKind.
 */
@Glossary
class UnreifiedRelationship extends EntityRelationship {}

/*
 * An OML Datatype is a common abstraction for what should be, in principle,
 * [OWL2 DataRange] of arity 1 (atomic) or > 1 (tuple structure).
 * In practice, an OML DataType maps to the [OWL2-DL] subset; which means
 * that an atomic OML Datatype maps to an [OWL2 Datatype] whereas
 * a structured OML Datatype maps to an [OWL2 Class].
 */
@Glossary
abstract class Datatype extends Term {}

/*
 * An OWL DataRange corresponds to an [OWL2 DataRange] with arity=1.
 */
@Glossary
abstract class DataRange extends Datatype {}

/*
 * An OML Scalar corresponds to an OWL2 Declaration of an [OWL2 DataRange] with arity=1.
 */
@Glossary
class Scalar extends DataRange, UnaryTermKind {}

/*
 * An OML DataRelationship is an OML DirectedBinaryRelationshipKind
 * where the domain or the range is some kind of OML Datatype.
 */
@Glossary
abstract class DataRelationship extends Term, DirectedBinaryRelationshipKind {
	
	@NotSchema
	op Term[1] source()
	
	@NotSchema
	@Override
	op Term[1] relationDomain() { source }
	
	@NotSchema
	op Datatype[1] target()
	
	@NotSchema
	@Override
	op Term[1] relationRange() { target }
}

/*
 * An OML DataRelationshipDomain is an abstraction 
 * for the domain of an OML DataRelationship
 */
@Glossary
abstract class DataRelationshipDomain {
	
	@FunctionalInterface
	op UUID[1] calculateUUID()
}

/*
 * An OML DataRelationshipFromEntity is an OML DataRelationship
 * whose domain is an OML Entity.
 */
@Glossary
abstract class DataRelationshipFromEntity extends DataRelationshipDomain {
	refers Entity[1] domain
	
	/*
	 * Specifies the OntoClean IdentityCriteria semantics of an OML DataRelationshipFromEntity:
	 * - +IC, if true; which means that every OML ConceptualEntity defined in a ClosedWorldDesignations OML Terminology
	 *   has an exact cardinality restriction of 1 for the possible values of the relationship, which is an
	 *   encoding in [OWL2-DL] of
	 * - ~IC, if false
	 */
	@Glossary
	boolean[1] isIdentityCriteria
}

/*
 * An OML DataRelationshipFromStructure is an OML DataRelationship
 * whose domain is an OML Structure.
 */
@Glossary
abstract class DataRelationshipFromStructure extends DataRelationshipDomain {
	refers Structure[1] domain
}

/*
 * An OML DataRelationshipRange is an abstraction 
 * for the range of an OML DataRelationship
 */
@Glossary
abstract class DataRelationshipRange {

	@FunctionalInterface
	op UUID[1] calculateUUID()
}

/*
 * An OML DataRelationshipToScalar is an OML DataRelationship 
 * whose range is an OML DataRange.
 */
@Glossary
abstract class DataRelationshipToScalar extends DataRelationshipRange {
	refers DataRange[1] range
}

/*
 * An OML DataRelationshipToStructure is an OML DataRelationship 
 * whose range is an OML Structure.
 */
@Glossary
abstract class DataRelationshipToStructure extends DataRelationshipRange {
	refers Structure[1] range
}

/*
 * An OML EntityStructuredDataProperty is an OML DataRelationship
 * whose domain is an OML Entity and range is an OML Structure.
 */
@Glossary
class EntityStructuredDataProperty extends DataRelationship, DataRelationshipFromEntity, DataRelationshipToStructure {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML EntityScalarDataProperty is an OML DataRelationship
 * whose domain is an OML Entity and range is an OML DataRange.
 */
@Glossary
class EntityScalarDataProperty extends DataRelationship, DataRelationshipFromEntity, DataRelationshipToScalar {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML StructuredDataProperty is an OML DataRelationship
 * whose domain is an OML Structure and range is an OML Structure.
 */
@Glossary
class StructuredDataProperty extends DataRelationship, DataRelationshipFromStructure, DataRelationshipToStructure {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML ScalarDataProperty is an OML DataRelationship
 * whose domain is an OML Structure and range is an OML DataRange.
 */
@Glossary
class ScalarDataProperty extends DataRelationship, DataRelationshipFromStructure, DataRelationshipToScalar {
	
	@NotSchema
	@Override
	op Term[1] source() { domain }
	
	@NotSchema
	@Override
	op Datatype[1] target() { range }
}

/*
 * An OML Structure would correspond to an OWL2 Declaration of an [OWL2 DataRange] with arity > 1.
 * However, since OWL2 Datatypes in the [OWL2-DL] are restricted to have arity=1,
 * the OML mapping to [OWL2-DL] involves a pattern-based usage of an [OWL2 Class] to represent an OML Structure.
 * The arity corresponds to the cardinality of the set of ScalarDataProperty & StructuredDataProperty 
 * relationships whose domain is this structure.
 */
@Glossary
class Structure extends Datatype, UnaryTermKind {}

/*
 * An OML Axiom maps to a pattern of [OWL2 Axioms].
 */
@Glossary
abstract class Axiom extends TerminologyBoxStatement {}

/*
 * An OML TerminologyAxiom is asserted in a TerminologyBox of some kind.
 */
@Glossary
abstract class TerminologyAxiom extends TerminologyThing {
	
	/*
	 * The source TerminologyBox
	 */
	@NotSchema
	op TerminologyBox[1] source()
	
	/*
	 * The target TerminologyBox
	 */
	@NotSchema
	op TerminologyBox[1] target()
}

/*
 * An OML TerminologyBoxAxiom is a TerminologyAxiom that asserts a logical statement about a Term.
 */
@Glossary
abstract class TerminologyBoxAxiom extends TerminologyAxiom {
	
	@CopyConstructor
	container TerminologyBox[1] tbox opposite terminologyBoxAxioms
}

/*
 * An OML TerminologyBundleAxiom is a TerminologyAxiom that asserts a logical statement in an OML Bundle.
 */
@Glossary
abstract class TerminologyBundleAxiom extends TerminologyAxiom {

	@CopyConstructor
	container Bundle[1] terminologyBundle opposite terminologyBundleAxioms

}

/*
 * An OML ConceptTreeDisjunction represents the root & non-leaf nodes of a concept taxonomy:
 * - Root node is a RootConceptTaxonomyAxiom.
 * - Non-leaf nodes are AnonymousConceptTaxonomyAxioms.
 */
@Glossary
abstract class ConceptTreeDisjunction {

	@FunctionalInterface
	op UUID[1] calculateUUID()
}

/*
 * An OML DisjointUnionOfConceptsAxiom(s) represents non-leaf & leaf nodes of a concept taxonomy:
 * - Each non-leaf node is an OML AnonymousConceptTaxonomyAxiom.
 * - Each leaf nodes is an OML SpecificDisjointConceptAxiom.
 */
@Glossary
abstract class DisjointUnionOfConceptsAxiom extends TerminologyBundleStatement {
	
	/*
	 * The parent of this node in a disjoint concept taxonomy tree.
	 */
	refers ConceptTreeDisjunction[1] disjointTaxonomyParent
}

/*
 * An OML SpecificDisjointConceptAxiom specifies a leaf in a taxonomy tree.
 */
@Glossary
class SpecificDisjointConceptAxiom extends DisjointUnionOfConceptsAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"SpecificDisjointConceptAxiom(bundle=\" + bundle.uuid + \",disjointLeaf=\"+disjointLeaf.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "SpecificDisjointConceptAxiom(bundle=" + bundle.uuid + ",disjointLeaf="+disjointLeaf.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * A Concept that is a disjoint leaf in a taxonomy tree.
	 */
	 refers Concept[1] disjointLeaf
}

/*
 * An OML AnonymousConceptTaxonomyAxiom is an anonymous taxonomy tree of DisjointUnionOfEntityAxioms.
 */
@Glossary
class AnonymousConceptTaxonomyAxiom extends DisjointUnionOfConceptsAxiom, ConceptTreeDisjunction {
	
	@NotSchema
	@Scala(code="
	val namespace = \"AnonymousConceptTaxonomyAxiom(bundle=\" + bundle.uuid + \",disjointTaxonomyParent=\"+disjointTaxonomyParent.calculateUUID()+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "AnonymousConceptTaxonomyAxiom(bundle=" + bundle.uuid + ",disjointTaxonomyParent="+disjointTaxonomyParent.calculateUUID()+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
}

/*
 * An OML RootConceptTaxonomyAxiom asserts that, in the scope of a Bundle, a particular Entity
 * is the root of a taxonomy of specializations of that Entity.
 */
@Glossary
class RootConceptTaxonomyAxiom extends TerminologyBundleStatement, ConceptTreeDisjunction {
	
	@NotSchema
	@Scala(code="
	val namespace = \"RootConceptTaxonomyAxiom(bundle=\" + bundle.uuid + \",root=\"+root.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "RootConceptTaxonomyAxiom(bundle=" + bundle.uuid + ",root="+root.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The Concept that is at the root of a taxonomy of disjunctions.
	 */
	refers Concept[1] root
	
}

/*
 * An OML BundledTerminologyAxiom identifies an OML TerminologyBox that an OML Bundle aggregates.
 * An OML BundledTerminologyAxiom allows an OML Bundle to
 * make references (via OML TerminologyStatement(s)) to OML TerminologyThing(s)
 * within the transitive closure of a bundledTerminology.
 */
@Glossary
class BundledTerminologyAxiom extends TerminologyBundleAxiom {

	@NotSchema
	@Scala(code="
	val namespace = \"BundledTerminologyAxiom(terminologyBundle=\" + terminologyBundle.uuid + \",bundledTerminology=\"+bundledTerminology.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "BundledTerminologyAxiom(terminologyBundle=" + terminologyBundle.uuid + ",bundledTerminology="+bundledTerminology.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	@CopyConstructor
	refers TerminologyBox[1] bundledTerminology
	
	/*
	 * The bundle is the source
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] source() { terminologyBundle }
	
	/*
	 * The bundledTerminology is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { bundledTerminology }
}

/*
 * An OML ConceptDesignationTerminologyAxiom establishes
 * a relationship from a source OML TerminologyBox
 * where a designated OML Concept is defined to
 * a target OML TerminologyGraph in which the internal
 * structure of the designated OML Concept can be defined. 
 */
@Glossary
class ConceptDesignationTerminologyAxiom extends TerminologyBoxAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"ConceptDesignationTerminologyAxiom(designationTerminologyGraph=\" + tbox.uuid + \",designatedConcept=\"+designatedConcept.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() {
		val namespace = "ConceptDesignationTerminologyAxiom(designationTerminologyGraph=" + tbox.uuid + ",designatedConcept="+designatedConcept.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}

	@NotSchema
	@Scala(code="tbox match { case g: TerminologyGraph => g }")
	op TerminologyGraph[1] designationTerminologyGraph() {
		switch tbox {
			TerminologyGraph:
				tbox as TerminologyGraph
		}
	}
	 
	@NotSchema
	@CopyConstructor
	refers TerminologyBox[1] designatedTerminology
	
	refers Concept[1] designatedConcept
	 
	/*
	 * The designationTerminologyGraph is the source
	 */
	@Scala(code="tbox")
	@NotSchema
	@Override
	op TerminologyBox[1] source() { getTbox }
	
	/*
	 * The TerminologyBox that asserts the designatedConcept is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { designatedTerminology }
}

/*
 * An OML TerminologyExtensionAxiom allows an extendingTerminology to
 * make references (via OML TerminologyBoxStatement(s)) to OML TerminologyThing(s)
 * declared within the transitive closure of the extendedTerminlogy.
 */
@Glossary
class TerminologyExtensionAxiom extends TerminologyBoxAxiom {

	@Scala(code="
	val namespace = \"TerminologyExtensionAxiom(source=\" + source.uuid + \",target=\"+target.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "TerminologyExtensionAxiom(source=" + source().uuid + ",target="+target().uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	@Scala(code="tbox")
	@NotSchema
	op TerminologyBox[1] extendingTerminology() { getTbox }
	
	@CopyConstructor
  	refers TerminologyBox[1] extendedTerminology
  	
	/*
	 * The extendingTerminology is the source
	 */
	@Scala(code="tbox")
	@NotSchema
	@Override
	op TerminologyBox[1] source() { getTbox }
	
	/*
	 * The extendedTerminology is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { extendedTerminology }
  	
}

/*
 * An OML TerminologyNestingAxiom provides support for relating
 * a white-box nested OML TerminologyGraph used for describing internal
 * details about a nesting OML Concept defined in a nesting OML TerminologyBox. 
 * This nesting OML Concept specifies the context for the internal details
 * defined in the nested OML TerminologyGraph.
 */
@Glossary
class TerminologyNestingAxiom extends TerminologyBoxAxiom {

	@Scala(code="
	val namespace = \"TerminologyNestingAxiom(source=\" + source.uuid + \",target=\"+target.uuid + \",nestingContext=\"+nestingContext.uuid + \")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "TerminologyNestingAxiom(source=" + source().uuid + ",target="+target().uuid+ ",nestingContext="+nestingContext.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
  	@CopyConstructor
	refers TerminologyBox[1] nestingTerminology

	@NotSchema
	@Scala(code="tbox match { case g: TerminologyGraph => g }")
	op TerminologyGraph[1] nestedTerminology() {
		switch tbox {
			TerminologyGraph:
				tbox as TerminologyGraph
		}
	}

  	refers Concept[1] nestingContext
  	
	/*
	 * The nestedTerminology is the source
	 */
	@Scala(code="tbox")
	@NotSchema
	@Override
	op TerminologyBox[1] source() { getTbox }
	
	/*
	 * The nestingTerminology is the target
	 */
	@NotSchema
	@Override
	op TerminologyBox[1] target() { nestingTerminology }
  	
}

/*
 * An OML TermAxiom is a logical axiom about an OML Term.
 */
@Glossary
abstract class TermAxiom extends Axiom {}

/*
 * An OML EntityRestrictionAxiom maps to an [OWL2 Object Property Restiction]
 * for an OML EntityRelationship.
 */
@Glossary
abstract class EntityRestrictionAxiom extends TermAxiom {

	 refers EntityRelationship[1] restrictedRelation

	 refers Entity[1] restrictedRange

	 refers Entity[1] restrictedDomain
}

/*
 * An OML EntityExistentialRestrictionAxiom maps 
 * to an [OWL2 Object Property Existential Restriction].
 */
@Glossary
class EntityExistentialRestrictionAxiom extends EntityRestrictionAxiom {
	
	@Scala(code="
	val namespace = \"EntityExistentialRestrictionAxiom(restrictedDomain=\" + restrictedDomain.uuid + \",restrictedRelation=\"+restrictedRelation.uuid + \",restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "EntityExistentialRestrictionAxiom(restrictedDomain=" + restrictedDomain.uuid + ",restrictedRelation="+restrictedRelation.uuid + ",restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
}

/*
 * An OML EntityUniversalRestrictionAxiom maps
 * to an [OWL2 Object Property Universal Restriction].
 */
@Glossary
class EntityUniversalRestrictionAxiom extends EntityRestrictionAxiom {
	
	@Scala(code="
	val namespace = \"EntityUniversalRestrictionAxiom(restrictedDomain=\" + restrictedDomain.uuid + \",restrictedRelation=\"+restrictedRelation.uuid + \",restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "EntityUniversalRestrictionAxiom(restrictedDomain=" + restrictedDomain.uuid + ",restrictedRelation="+restrictedRelation.uuid + ",restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
}

/*
 * An OML SpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific and a general OML Entity.
 */
@Glossary
abstract class SpecializationAxiom extends TermAxiom {
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	op Entity[1] child()
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	op Entity[1] parent()
}

/*
 * An OML AspectSpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific OML Aspect 
 * and a general OML Entity.
 */
@Glossary
class AspectSpecializationAxiom extends SpecializationAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"AspectSpecializationAxiom(subEntity=\" + subEntity.uuid + \",superAspect=\"+superAspect.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "AspectSpecializationAxiom(subEntity=" + subEntity.uuid + ",superAspect="+superAspect.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The sub (child) entity
	 */
	refers Entity[1] subEntity
	/*
	 * The super (parent) aspect
	 */
	refers Aspect[1] superAspect
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Entity[1] child() { subEntity }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Entity[1] parent() { superAspect }
}

/*
 * An OML ConceptSpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific and general
 * OML Concept.
 */
@Glossary
class ConceptSpecializationAxiom extends SpecializationAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"ConceptSpecializationAxiom(subConcept=\" + subConcept.uuid + \",superConcept=\"+superConcept.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ConceptSpecializationAxiom(subConcept=" + subConcept.uuid + ",superConcept="+superConcept.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	refers Concept[1] subConcept
	refers Concept[1] superConcept
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Entity[1] child() { subConcept }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Entity[1] parent() { superConcept }
}

/*
 * An OML ReifiedRelationshipSpecializationAxiom is a logical axiom
 * about a taxonomic relationship between a specific and general
 * OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipSpecializationAxiom extends SpecializationAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"ReifiedRelationshipSpecializationAxiom(subRelationship=\" + subRelationship.uuid + \",superRelationship=\"+superRelationship.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ReifiedRelationshipSpecializationAxiom(subRelationship=" + subRelationship.uuid + ",superRelationship="+superRelationship.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The sub (child) relationship
	 */
	refers ReifiedRelationship[1] subRelationship
	/*
	 * The super (parent) relationship
	 */
	refers ReifiedRelationship[1] superRelationship
	/*
	 * Get the sub (child) entity
	 */
	@NotSchema
	@Override
	op Entity[1] child() { subRelationship }
	/*
	 * Get the super (parent) entity
	 */
	@NotSchema
	@Override
	op Entity[1] parent() { superRelationship }
}

/*
 * An OML EntityScalarDataPropertyRestrictionAxiom maps to
 * some kind of OWL2 Data Property Restriction.
 */
@Glossary
abstract class EntityScalarDataPropertyRestrictionAxiom extends TermAxiom {
	refers Entity[1] restrictedEntity
  	refers EntityScalarDataProperty[1] scalarProperty
}

/*
 * An OML EntityScalarDataPropertyExistentialRestrictionAxiom maps to an 
 * OWL2 DataSomeValuesFrom restriction (the range must be explicitly defined as a Scalar datatype)
 */
@Glossary
class EntityScalarDataPropertyExistentialRestrictionAxiom 
extends EntityScalarDataPropertyRestrictionAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"EntityScalarDataPropertyExistentialRestrictionAxiom(restrictedEntity=\"+restrictedEntity.uuid+\",scalarProperty=\"+scalarProperty.calculateUUID()+\",scalarRestriction=\"+scalarRestriction.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "EntityScalarDataPropertyExistentialRestrictionAxiom(restrictedEntity=" + restrictedEntity.uuid + ",scalarProperty="+scalarProperty.calculateUUID()+ ",scalarRestriction="+scalarRestriction.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
  	refers DataRange[1] scalarRestriction
}

/*
 * An OML EntityScalarDataPropertyUniversalRestrictionAxiom maps to an
 * OWL2 DataAllValuesFrom (the range must be explicitly defined as a Scalar datatype)
 */
@Glossary
class EntityScalarDataPropertyUniversalRestrictionAxiom 
extends EntityScalarDataPropertyRestrictionAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"EntityScalarDataPropertyUniversalRestrictionAxiom(restrictedEntity=\"+restrictedEntity.uuid+\",scalarProperty=\"+scalarProperty.calculateUUID()+\",scalarRestriction=\"+scalarRestriction.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "EntityScalarDataPropertyUniversalRestrictionAxiom(restrictedEntity=" + restrictedEntity.uuid + ",scalarProperty="+scalarProperty.calculateUUID()+ ",scalarRestriction="+scalarRestriction.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
  	refers DataRange[1] scalarRestriction
}

/**
 * An OML EntityScalarDataPropertyParticularRestrictionAxiom maps to an OWL2 DataHasValue restriction.
 */
@Glossary
class EntityScalarDataPropertyParticularRestrictionAxiom
extends EntityScalarDataPropertyRestrictionAxiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"EntityScalarDataPropertyParticularRestrictionAxiom(restrictedEntity=\"+restrictedEntity.uuid+\",scalarProperty=\"+scalarProperty.calculateUUID()+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "EntityScalarDataPropertyParticularRestrictionAxiom(restrictedEntity=" + restrictedEntity.uuid + ",scalarProperty="+scalarProperty.calculateUUID()+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	LexicalValue[1] literalValue
}

/*
 * An OML RestrictedDataRange corresponds to an [OWL2 DataRange] defined
 * in terms of some kind of restriction of some other OML DataRange.
 * The specializations of OML RestrictedDataRange correspond to
 * the allowed restrictions in the [OWL2 Datatype Maps].
 * Node that the vocabulary of XSD fundamental facets is not included in OWL2-DL, consequently, 
 * there is no support in OML for specifying datatype restrictions involving XSD fundamental facets as well.
 * Each specialization maps to an OWL2 Declaration of an [OWL2 Datatype] whose
 * [OWL2 DataRange] corresponds to the OWL2 mapping of that specialized restriction.
 */ 
@Glossary
abstract class RestrictedDataRange extends DataRange {
	/*
	 * The restricted (general) data range of this data range (specific)
	 */
	refers DataRange[1] restrictedRange
}

/*
 * An OML BinaryScalarRestriction is a data range that specifies how one binary scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [OWL2 Binary Data].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:base64Binary]
 * - [xsd:hexBinary]
 * 
 * Facets:
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 */
@Glossary
class BinaryScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"BinaryScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "BinaryScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The length of the binary data
	 */
	int[?] length
	/*
	 * The minimum length of the binary data
	 */
	int[?] minLength
	/*
	 * The maximum length of the binary data
	 */
	int[?] maxLength
}

/*
 * An OML IRIScalarRestriction is a data range that specifies how one IRI scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents an [OWL2 IRI].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:anyURI]
 * 
 * Facets:
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 * - [xsd:pattern]
 */
@Glossary
class IRIScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"IRIScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "IRIScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The length of the IRI
	 */
	int[?] length
	/*
	 * The minimum length of the IRI
	 */
	int[?] minLength
	/*
	 * The maximum length of the IRI
	 */
	int[?] maxLength
	/*
	 * The pattern of the IRI (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	Pattern[?] pattern
}

/*
 * An OML NumericScalarRestriction is a data range that specifies how one numeric scalar range adds facet restrictions to another.
 * Applies when the restricted scalar represents [OWL2 Real Numbers, Decimal Numbers and Integers] or [OWL2 Floating-Point Numbers].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [owl:real]
 * - [owl:rational]
 * - [xsd:decimal]
 * - [xsd:integer]
 * - [xsd:nonNegativeInteger]
 * - [xsd:nonPositiveInteger]
 * - [xsd:positiveInteger]
 * - [xsd:negativeInteger]
 * - [xsd:long]
 * - [xsd:int]
 * - [xsd:short]
 * - [xsd:byte]
 * - [xsd:unsignedLong]
 * - [xsd:unsignedInt]
 * - [xsd:unsignedShort]
 * - [xsd:unsignedByte]
 * - [xsd:double]
 * - [xsd:float]
 * 
 * Facets:
 * - [xsd:minInclusive]
 * - [xsd:maxInclusive]
 * - [xsd:minExclusive]
 * - [xsd:maxExclusive]
 */
@Glossary
class NumericScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"NumericScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "NumericScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The inclusive minimum value in the range
	 */
	LexicalNumber[?] minInclusive
	/*
	 * The inclusive maximum value in the range
	 */
	LexicalNumber[?] maxInclusive
	/*
	 * The exclusive minimum value in the range
	 */
	LexicalNumber[?] minExclusive
	/*
	 * The exclusive maximum value in the range
	 */
	LexicalNumber[?] maxExclusive
}

/*
 * An OML PlainLiteralScalarRestriction is a data range that specifies how one plain literal scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [rdf:PlainLiteral].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [rdf:PlainLiteral]
 * 
 * Facets:
 * - [xsd:langRange]
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 * - [xsd:pattern]
 */
@Glossary
class PlainLiteralScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"PlainLiteralScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "PlainLiteralScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The length of the plain literal
	 */
	int[?] length
	/*
	 * The minimum length of the plain literal
	 */
	int[?] minLength
	/*
	 * The maximum length of the plain literal
	 */
	int[?] maxLength
	/*
	 * The pattern of the plain literal (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	Pattern[?] pattern
	/*
	 * The language of the plain literal (http://www.rfc-editor.org/rfc/bcp/bcp47.txt)
	 */
	LangRange[?] langRange
}

/*
 * An OML StringScalarRestriction is a data range that specifies how one string scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [OWL2 Strings].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:string]
 * - [xsd:normalizedString]
 * - [xsd:token]
 * - [xsd:language]
 * - [xsd:Name]
 * - [xsd:NCName]
 * - [xsd:NMTOKEN]
 * 
 * Facets:
 * - [xsd:length]
 * - [xsd:minLength]
 * - [xsd:maxLength]
 * - [xsd:pattern]
 */
@Glossary
class StringScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"StringScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "StringScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The length of the string
	 */
	int[?] length
	/*
	 * The minimum length of the string
	 */
	int[?] minLength
	/*
	 * The maximum length of the string
	 */
	int[?] maxLength
	/*
	 * The pattern of the string (https://www.w3.org/TR/xmlschema-2/#regexs)
	 */
	Pattern[?] pattern
}

/*
 * An OML TimeScalarRestriction is a data range that specifies how one time scalar adds facet restrictions to another.
 * Applicable when the restricted scalar represents [OWL2 Time Instants].
 * 
 * The restricted scalar must be directly or indirectly a restriction of:
 * - [xsd:dateTime]
 * - [xsd:dateTimeStamp]
 * 
 * Facets:
 * - [xsd:minInclusive]
 * - [xsd:maxInclusive]
 * - [xsd:minExclusive]
 * - [xsd:maxExclusive]
 */
@Glossary
class TimeScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"TimeScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "TimeScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	/*
	 * The inclusive minimum value in the range
	 */
	LexicalTime[?] minInclusive
	/*
	 * The inclusive maximum value in the range
	 */
	LexicalTime[?] maxInclusive
	/*
	 * The exclusive minimum value in the range
	 */
	LexicalTime[?] minExclusive
	/*
	 * The exclusive maximum value in the range
	 */
	LexicalTime[?] maxExclusive
}

/*
 * An OML SynonymScalarRestriction is a data range that is defined as a synonym for another (i.e. the restrictedRange).
 */
@Glossary
class SynonymScalarRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"SynonymScalarRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "SynonymScalarRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
}

/*
 * An OML ScalarOneOfRestriction is a data range that specifies how a scalar is a restricted set of literal values of another.
 * Semantics: OWL2 DataOneOf
 */
@Glossary
class ScalarOneOfRestriction extends RestrictedDataRange {
	
	@NotSchema
	@Scala(code="
	val namespace = \"ScalarOneOfRestriction(restrictedRange=\"+restrictedRange.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ScalarOneOfRestriction(restrictedRange="+restrictedRange.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
}

/*
 * An OML ScalarOneOfLiteralAxiom specifies a literal in a ScalarOneOfRestriction data range.
 */
@Glossary
class ScalarOneOfLiteralAxiom extends Axiom {
	
	@NotSchema
	@Scala(code="
	val namespace = \"ScalarOneOfLiteralAxiom(scalarOneOfRestriction=\"+axiom.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ScalarOneOfLiteralAxiom(scalarOneOfRestriction="+axiom.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}

	refers ScalarOneOfRestriction[1] axiom
	/*
	 * The value of the literal from the restrictedScalar datatype
	 */
	LexicalValue[1] value
}

/*
 * OML DescriptionKind specifies semantic constraints that apply to
 * an OML DescriptionBox as follows:
 * | OML SingletonInstance 					| Final					| Partial 	|
 * |========================================|=======================|===========|
 * | OML ConceptualEntitySingletonInstance	| Concrete OML ConceptualEntity | Any OML ConceptualEntity  |
 */
@Glossary
enum DescriptionKind {
	Final
	Partial
}

/*
 * An OML DescriptionBox maps to an [OWL2-DL Ontology]
 * about [OWL2-DL NamedIndividuals] mapped from OML TerminologyInstanceAssertion(s).
 */
@Glossary
class DescriptionBox extends Module {
	
	@NotSchema
	@Scala(code="copy(annotations = this.annotations ++ resolver.convertToAnnotations(a))")
	@Override
	op DescriptionBox[1] withAnnotations
	(@Collection(kind="SortedSet") AnnotationPropertyTable[] a)
	
	@NotSchema
	@Scala(code="resolver.groupAnnotationsByProperty(annotations)")
	@Collection(kind="SortedSet")
	@Override
	op AnnotationPropertyTable[] annotationsByProperty()	
	
	DescriptionKind[1] kind
	
	@NotSchema
	op TerminologyExtent[1] extent() { descriptionExtent }
	
	@NotSchema
	container TerminologyExtent[1] descriptionExtent opposite descriptions
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains DescriptionBoxExtendsClosedWorldDefinitions[] closedWorldDefinitions opposite descriptionBox
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains DescriptionBoxRefinement[] descriptionBoxRefinements opposite refiningDescriptionBox
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains ConceptInstance[] conceptInstances opposite descriptionBox
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains ReifiedRelationshipInstance[] reifiedRelationshipInstances opposite descriptionBox
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains ReifiedRelationshipInstanceDomain[] reifiedRelationshipInstanceDomains opposite descriptionBox
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains ReifiedRelationshipInstanceRange[] reifiedRelationshipInstanceRanges opposite descriptionBox
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains UnreifiedRelationshipInstanceTuple[] unreifiedRelationshipInstanceTuples opposite descriptionBox
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.Entity]")
	@Collection(kind="SortedSet")
	@Override
	op Entity[] entities()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.Aspect]")
	@Collection(kind="SortedSet")
	@Override
	op Aspect[] aspects()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.Concept]")
	@Collection(kind="SortedSet")
	@Override
	op Concept[] concepts()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.ReifiedRelationship]")
	@Collection(kind="SortedSet")
	@Override
	op ReifiedRelationship[] reifiedRelationships()
		
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.UnreifiedRelationship]")
	@Collection(kind="SortedSet")
	@Override
	op UnreifiedRelationship[] unreifiedRelationships()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.DataRelationship]")
	@Collection(kind="SortedSet")
	@Override
	op DataRelationship[] dataRelationships()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.EntityScalarDataProperty]")
	@Collection(kind="SortedSet")
	@Override
	op EntityScalarDataProperty[] entityScalarDataProperties()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.DataRange]")
	@Collection(kind="SortedSet")
	@Override
	op DataRange[] dataranges()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.Scalar]")
	@Collection(kind="SortedSet")
	@Override
	op Scalar[] scalars()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.Structure]")
	@Collection(kind="SortedSet")
	@Override
	op Structure[] structures()
	
    @NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.TermAxiom]")
	@Collection(kind="SortedSet")
	@Override
	op TermAxiom[] termAxioms()
	
	@NotSchema
	@Scala(code="scala.collection.immutable.SortedSet.empty[resolver.api.TerminologyThing] ++ 
	conceptInstances ++
	reifiedRelationshipInstances ++ 
	reifiedRelationshipInstanceDomains ++ 
	reifiedRelationshipInstanceRanges ++ 
	unreifiedRelationshipInstanceTuples")
	@Collection(kind="SortedSet")
	@Override
	op TerminologyThing[] everything()
}

/*
 * An OML DescriptionBoxRelationship is a directed binary relationship
 * from an OML DescriptionBox source to an OML Module target.
 */
@Glossary
abstract class DescriptionBoxRelationship extends TerminologyThing {
	
	@NotSchema
	op DescriptionBox[1] descriptionDomain()
	
	@NotSchema
	op Module[1] targetModule()
}

/*
 * An OML DescriptionBoxExtendsClosedWorldDefinition specifies
 * an OML DescriptionBoxRelationship from an OML DescriptionBox 
 * to an OML TerminologyBox such that an OML SingletonInstance defined in the
 * former can be an instance of an OML Term defined in the latter.
 */
@Glossary
class DescriptionBoxExtendsClosedWorldDefinitions extends DescriptionBoxRelationship {
	
	@Scala(code="
	val namespace = \"DescriptionBoxExtendsClosedWorldDefinitions(descriptionBox=\" + descriptionBox.uuid + \",closedWorldDefinitions=\"+closedWorldDefinitions.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "DescriptionBoxExtendsClosedWorldDefinitions(descriptionBox=" + descriptionBox.uuid + ",closedWorldDefinitions="+closedWorldDefinitions.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] descriptionBox opposite closedWorldDefinitions
	
	@NotSchema
	op DescriptionBox[1] descriptionDomain() { descriptionBox }
	
	refers TerminologyBox[1] closedWorldDefinitions
	
	@NotSchema
	op Module[1] targetModule() { closedWorldDefinitions }
}

/*
 * An OML DescriptionBoxRefinement is an OML DescriptionBoxRelationship
 * from an OML DescriptionBox to another OML DescriptionBox where
 * the former refines the descriptions of the latter.
 */
@Glossary
class DescriptionBoxRefinement extends DescriptionBoxRelationship {
	
	@Scala(code="
	val namespace = \"DescriptionBoxRefinement(refiningDescriptionBox=\" + refiningDescriptionBox.uuid + \",refinedDescriptionBox=\"+refinedDescriptionBox.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "DescriptionBoxRefinement(refiningDescriptionBox=" + refiningDescriptionBox.uuid + ",refinedDescriptionBox="+refinedDescriptionBox.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] refiningDescriptionBox opposite descriptionBoxRefinements
	
	@NotSchema
	op DescriptionBox[1] descriptionDomain() { refiningDescriptionBox }
	
	refers DescriptionBox[1] refinedDescriptionBox
	
	@NotSchema
	op Module[1] targetModule() { refinedDescriptionBox }
}

/*
 * An OML TerminologyInstanceAssertion is a logical OML TerminologyThing defined in an OML TerminologyDescription.
 */
@Glossary
abstract class TerminologyInstanceAssertion extends TerminologyThing, Resource {
	@NotSchema
	op DescriptionBox[1] descriptionBox()
	
	/*
	 * The UUID of a Term is a Version5 namespace UUID based on the term's IRI.
	 */
	@Scala(code="com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri())")
	@NotSchema 
	@Override
	op UUID[1] calculateUUID() { 
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(iri()).toString
	}
	
	@Scala(code="descriptionBox.iri + \"#\" + name")
	@NotSchema
	@Override
	op IRI[1] iri() { descriptionBox.iri() + "#" + name() }
	
	@Override
	id LocalName[1] name
	
	@NotFunctionalAPI
	@NotSchema
	op LocalName[1] name() { getName() }
}

/*
 * An OML SingletonInstance defines an instance of either an OML ConceptualEntity or of an OML Structure.
 */
@Glossary
abstract class SingletonInstance extends TerminologyInstanceAssertion {
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains ScalarDataPropertyValue[] scalarDataPropertyValues opposite singletonInstance
	
	@CopyConstructor
	@Collection(kind="SortedSet")
	contains StructuredDataPropertyValue[] structuredDataPropertyValues opposite singletonInstance
}

/*
 * An OML ScalarDataPropertyValue defines a tuple for representing the atomic String value
 * of an OML DataRelationshipToScalar for a particular OML SingletonInstance.
 */
@Glossary
class ScalarDataPropertyValue extends TerminologyInstanceAssertion {
	
	@Scala(code="
	val namespace = \"ScalarDataPropertyValue(singletonInstance=\" + singletonInstance.uuid + \",scalarDataProperty=\"+scalarDataProperty.calculateUUID()+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ScalarDataPropertyValue(singletonInstance=" + singletonInstance.uuid + ",scalarDataProperty="+scalarDataProperty.calculateUUID()+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	@NotSchema
	op DescriptionBox[1] descriptionBox() { singletonInstance.descriptionBox() }
	
	container SingletonInstance[1] singletonInstance opposite scalarDataPropertyValues
	refers DataRelationshipToScalar[1] scalarDataProperty
	String[1] scalarPropertyValue
}

/*
 * 
 * An OML StructuredDataPropertyValue defines a tuple for representing the structured tuple value
 * of an OML DataRelationshipToStructure for a particular OML SingletonInstance.
 */
@Glossary
class StructuredDataPropertyValue extends TerminologyInstanceAssertion {
	
	@Scala(code="
	val namespace = \"StructuredDataPropertyValue(singletonInstance=\" + singletonInstance.uuid + \",structuredDataProperty=\"+structuredDataProperty.calculateUUID()+ \",structuredPropertyTuple=\"+structuredPropertyTuple.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "StructuredDataPropertyValue(singletonInstance=" + singletonInstance.uuid + ",structuredDataProperty="+structuredDataProperty.calculateUUID() + ",structuredPropertyTuple="+structuredPropertyTuple.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	@NotSchema
	op DescriptionBox[1] descriptionBox() { singletonInstance.descriptionBox() }
	
	container SingletonInstance[1] singletonInstance opposite structuredDataPropertyValues
	refers DataRelationshipToStructure[1] structuredDataProperty
	contains DataStructureTuple[1] structuredPropertyTuple opposite structuredDataPropertyValue
}

/*
 * An OML DataStructureTuple defines an structured tuple instance of an OML Structure.
 */
@Glossary
class DataStructureTuple extends SingletonInstance {
	
	@Scala(code="
	val namespace = \"DataStructureTuple(structuredDataPropertyValue=\" + structuredDataPropertyValue.uuid + \",dataStructureType=\"+dataStructureType.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "DataStructureTuple(structuredDataPropertyValue=" + structuredDataPropertyValue.uuid + ",dataStructureType="+dataStructureType.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	@NotSchema
	op DescriptionBox[1] descriptionBox() { structuredDataPropertyValue.descriptionBox() }
	
	container StructuredDataPropertyValue[1] structuredDataPropertyValue opposite structuredPropertyTuple
	
	refers Structure[1] dataStructureType
}

/*
 * An OML ConceptualEntitySingletonInstance defines an instance of an OML ConceptualEntity.
 * An OML ConceptualEntitySingletonInstance maps to an [OWL2 NamedIndividual].
 * The semantics depends on the kind of OML ConceptualEntity classifier:
 * - If the OML ConceptualEntity is the domain for at least at least 
 *   one OML DataRelationshipFromEntity with `isIdentityCriteria=true`,
 *   then the [OWL2-DL] mapping includes an [OWL2 Key Axiom]
 *   forcing that all distinctly named OML ConceptualEntitySingletonInstance 
 *   must have different values for each OML DataRelationshipFromEntity with `isIdentityCriteria=true`.
 * - otherwise, distinctly named OML ConceptualEntitySingletonInstance 
 *   represent semantically different instances.
 */
@Glossary
abstract class ConceptualEntitySingletonInstance extends SingletonInstance {
	
	@NotSchema
	op ConceptualEntity[1] conceptualEntitySingletonClassifier()
	
	@NotSchema
	@Scala(code="scalarDataPropertyValues.filter{ v =>
	  v.scalarDataProperty match {
	    case ep: EntityScalarDataProperty =>
		  ep.isIdentityCriteria
	    case _ =>
	      false
	  }}")
	@Collection(kind="SortedSet")
	op ScalarDataPropertyValue[] identifyingScalarValues() {
		scalarDataPropertyValues
		.filter[v | 
			val p = v.scalarDataProperty 
			switch p {
			EntityScalarDataProperty:
				p.isIdentityCriteria
			default:
				false
			}]
		.asEList
		
	}
	
	@NotSchema
	@Scala(code="structuredDataPropertyValues.filter{ v =>
	  v.structuredDataProperty match {
	    case ep: EntityStructuredDataProperty =>
		  ep.isIdentityCriteria
	    case _ =>
	      false
	  }}")
	@Collection(kind="SortedSet")
	op StructuredDataPropertyValue[] identifyingStructuredTuples() { 
		structuredDataPropertyValues
		.filter[v | 
			val p = v.structuredDataProperty 
			switch p {
			EntityStructuredDataProperty:
				p.isIdentityCriteria
			default:
				false
			}]
		.asEList
	}
}

/*
 * An OML ConceptInstance is an OML ConceptualEntitySingletonInstance classified by an OML Concept.
 */
@Glossary
class ConceptInstance extends ConceptualEntitySingletonInstance {
	
	@Scala(code="
	val namespace = \"ConceptInstance(descriptionBox=\" + descriptionBox.uuid + \",singletonConceptClassifier=\"+singletonConceptClassifier.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ConceptInstance(descriptionBox=" + descriptionBox().uuid + ",singletonConceptClassifier="+singletonConceptClassifier.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] descriptionBox opposite conceptInstances
	
	refers Concept[1] singletonConceptClassifier
	
	@NotSchema
	@Override
	op ConceptualEntity[1] conceptualEntitySingletonClassifier() { singletonConceptClassifier }
}

/*
 * An OML ReifiedRelationshipInstance is an OML ConceptualEntitySingletonInstance  classified by an OML ReifiedRelationship.
 */
@Glossary
class ReifiedRelationshipInstance extends ConceptualEntitySingletonInstance {
	
	@Scala(code="
	val namespace = \"ReifiedRelationshipInstance(descriptionBox=\" + descriptionBox.uuid + \",singletonReifiedRelationshipClassifier=\"+singletonReifiedRelationshipClassifier.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ReifiedRelationshipInstance(descriptionBox=" + descriptionBox().uuid + ",singletonReifiedRelationshipClassifier="+singletonReifiedRelationshipClassifier.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] descriptionBox opposite reifiedRelationshipInstances
	
	refers ReifiedRelationship[1] singletonReifiedRelationshipClassifier
	
	@NotSchema
	@Override
	op ConceptualEntity[1] conceptualEntitySingletonClassifier() { singletonReifiedRelationshipClassifier }
}

/*
 * An OML ReifiedRelationshipInstanceDomain specifies which OML ConceptualEntitySingletonInstance
 * plays the role of the domain for an OML ReifiedRelationshipInstance.
 * An OML ReifiedRelationshipInstanceDomain has no intrinsic identity; instead,
 * an OML ReifiedRelationshipInstanceDomain is semantically equivalent 
 * to another OML ReifiedRelationshipInstanceDomain referencing the same property and domain.
 */
@Glossary
class ReifiedRelationshipInstanceDomain extends TerminologyInstanceAssertion {
	
	@Scala(code="
	val namespace = \"ReifiedRelationshipInstanceDomain(descriptionBox=\" + descriptionBox.uuid + \",reifiedRelationshipInstance=\"+reifiedRelationshipInstance.uuid+ \",domain=\"+domain.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ReifiedRelationshipInstanceDomain(descriptionBox=" + descriptionBox().uuid + ",reifiedRelationshipInstance="+reifiedRelationshipInstance.uuid + ",domain="+domain.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] descriptionBox opposite reifiedRelationshipInstanceDomains
	refers ReifiedRelationshipInstance[1] reifiedRelationshipInstance
	refers ConceptualEntitySingletonInstance[1] domain
}

/*
 * An OML ReifiedRelationshipInstanceRange specifies which OML ConceptualEntitySingletonInstance
 * plays the role of the range for an OML ReifiedRelationshipInstance.
 * An OML ReifiedRelationshipInstanceRange has no intrinsic identity; instead,
 * an OML ReifiedRelationshipInstanceRange is semantically equivalent 
 * to another OML ReifiedRelationshipInstanceRange referencing the same property and range.
 */
@Glossary
class ReifiedRelationshipInstanceRange extends TerminologyInstanceAssertion {
	
	@Scala(code="
	val namespace = \"ReifiedRelationshipInstanceRange(descriptionBox=\" + descriptionBox.uuid + \",reifiedRelationshipInstance=\"+reifiedRelationshipInstance.uuid+ \",range=\"+range.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "ReifiedRelationshipInstanceRange(descriptionBox=" + descriptionBox().uuid + ",reifiedRelationshipInstance="+reifiedRelationshipInstance.uuid + ",range="+range.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] descriptionBox opposite reifiedRelationshipInstanceRanges
	refers ReifiedRelationshipInstance[1] reifiedRelationshipInstance
	refers ConceptualEntitySingletonInstance[1] range
}

/*
 * An OML UnreifiedRelationshipInstanceTuple specifies a triple involving
 * a reference to an OML ConceptualEntitySingletonInstance playing the role of the domain
 * of an OML UnreifiedRelationship whose range is played by a reference to an OML ConceptualEntitySingletonInstance.
 * An OML UnreifiedRelationshipInstanceTuple has no intrinsic identity; instead,
 * an OML UnreifiedRelationshipInstanceTuple is semantically equivalent 
 * to another OML UnreifiedRelationshipInstanceTuple referencing the same domain, property and range.
 */
@Glossary
class UnreifiedRelationshipInstanceTuple extends TerminologyInstanceAssertion {
	
	@Scala(code="
	val namespace = \"UnreifiedRelationshipInstanceTuple(descriptionBox=\" + descriptionBox.uuid + \",unreifiedRelationship=\"+unreifiedRelationship.uuid+ \",domain=\"+domain.uuid+ \",range=\"+range.uuid+\")\"
	com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace)")
	@NotSchema
	@Override
	op UUID[1] calculateUUID() { 
		val namespace = "UnreifiedRelationshipInstanceTuple(descriptionBox=" + descriptionBox().uuid + ",unreifiedRelationship="+unreifiedRelationship.uuid + ",domain="+domain.uuid + ",range="+range.uuid+")"
		com.fasterxml.uuid.Generators.nameBasedGenerator(com.fasterxml.uuid.impl.NameBasedGenerator.NAMESPACE_URL).generate(namespace).toString
	}
	
	container DescriptionBox[1] descriptionBox opposite unreifiedRelationshipInstanceTuples
	refers UnreifiedRelationship[1] unreifiedRelationship
	refers ConceptualEntitySingletonInstance[1] domain
	refers ConceptualEntitySingletonInstance[1] range
}